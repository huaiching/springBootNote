# 後端 的 增刪改查

## Criterion：條件設定

- 一個變數
  
  ```java
  Criterion.single(欄位, 運算符號, 數值)
  ```
  
  - 欄位：使用`小駝峰`。
  
  - 常用的運算符號
    
    ```java
    QueryOperator.EQUAL                 : 等於
    QueryOperator.NOT_EQUAL             : 不等於
    QueryOperator.LESS_THAN             : 小於
    QueryOperator.LESS_THAN_OR_EQUAL    : 小於等於
    QueryOperator.GREATER_THAN          : 大於
    QueryOperator.GREATER_THAN_OR_EQUAL : 大於等於
    QueryOperator.START_WITH     : 以指定字串開頭
    QueryOperator.NOT_START_WITH : 不以指定字串開頭
    QueryOperator.END_WITH     : 以指定字串結尾
    QueryOperator.NOT_END_WITH : 不以指定字串結尾
    QueryOperator.LIKE     : 包含指定字串
    QueryOperator.NOT_LIKE : 不包含指定字串
    QueryOperator.NULL     : 值為NULL
    QueryOperator.NOT_NULL : 值不為NULL
    ```
  
  - 範例：
    
    ```java
    Criterion criterion =  Criterion.single("clientId", Criterion.QueryOperator.EQUAL, clientId);
    ```

- 多個變數
  
  ```java
  Criterion.between(欄位, 前數值, 後數值)
  Criterion.in(欄位, LIST<Object> 數值)
  Criterion.notIn(欄位, LIST<Object> 數值)
  ```
  
  - 範例
    
    ```java
    List<Object> policyNoList = poclList.stream()
                    .map(PoclEntity::getPolicyNo).distinct().collect(Collectors.toList());
    Criterion criterion =  Criterion.in("policyNo", policyNoList);
    ```

- 多個條件
  
  ```java
  Criterion.and(
      Criterion.single(欄位, 運算符號, 數值),
      Criterion.in(欄位, LIST<Object> 數值),
      ......
  )
  ```
  
  - 範例
    
    ```java
    Criterion criterion = Criterion.and(
        Criterion.single("clientId", Criterion.QueryOperator.EQUAL, addrKey.getClientId()),
        Criterion.single("addrInd", Criterion.QueryOperator.EQUAL, addrKey.getAddrInd())
    );
    ```

## 簡單的查詢

- 查詢 - 一筆資料
  
  透過 `viewQueryService.findOneSpec` 進行查詢。
  
  ```java
  @Autowired
  private ViewQueryService viewQueryService;
  
  public ClntEntity queryClntByClientId(String clientId) {
      // 透過 Criterion 設定 查詢的 where
      Criterion criterion =  Criterion.single("clientId", Criterion.QueryOperator.EQUAL, clientId);
      // 查詢資料 僅 一筆，透過 viewQueryService.findOneSpec 進行查詢
      Optional<?> clntOptional = viewQueryService.findOneSpec(ClntEntity.class, criterion);
      // 查詢完畢 需要 針對 無資料 進行處理
      if(clntOptional.isEmpty()){
          return null;
      }
      ClntEntity clntEntity = (ClntEntity)clntOptional.get();
      return clntEntity ;
  }
  ```

- 查詢 - 多筆資料
  
  透過 `viewQueryService.querySpec` 進行查詢。
  
  ```java
  @Autowired
  private ViewQueryService viewQueryService;
  
  public List<AddrEntity> queryAddrByClientId(String clientId) {
      // 透過 Criterion 設定 查詢的 where
      Criterion criterion = Criterion.and(
              Criterion.single("clientId", Criterion.QueryOperator.EQUAL, clientId)
              // 有 多個 查詢條件 繼續往下設定
      );
      // 查詢資料 有 多筆，透過 viewQueryService.querySpec 進行查詢
      List<AddrEntity> addrList = viewQueryService.querySpec(AddrEntity.class, criterion);
      // 查詢完畢 需要 針對 無資料 進行處理
      if (addrList.isEmpty()) {
          return null;
      }
      return viewQueryService.querySpec(AddrEntity.class, criterion);
  }
  ```

## 複雜的查詢 - QueryHandler

此方式 是透過 `nativeQuery` 的方式，來執行 `複雜的SQL` 查詢。

- 程式放置於 `handler.query` 裡面。

- class 上方要有
  
  ```java
  @QueryHandler
  @MethodOverloadForbidden
  ```

- 透過 `viewQueryService.executeByServiceMethod()` 執行。

- `@QueryMethod`：查詢內容設定
  
  - name：對應 方法名稱
  
  - nativeQuery = true：代表使用 nativeQuery 的原生SQL 查詢
  
  - resultRecordType：回傳保存的 DTO/VO class
  
  - value: 你的 SQL 語句
    
    - 欄位 串聯 使用 JOIN - ON
    
    - 不要使用 WHERE 不然會導致 執行時 SQL 語句錯誤
      
      因為 條件透過 `Criterion` 設定
      
      而 `Criterion` 會使用 `where` 寫入 `SQL 語語句` 中

- @QueryFilter：條件設定
  
  - name：Criterion 裡面的欄位名稱
  
  - expr：SQL語句中，`where` 的欄位名稱

```java
@QueryHandler
@MethodOverloadForbidden
public class CmntQueryHandler {
    @Autowired
    @Lazy //避免循環引用
    private ViewQueryService viewQueryService;

    /**
     * 取得 批註主要資料
     * @param criterion
     * @return List<QueryCmntMainDTO>
     */
    @QueryMethod(name = "queryCmntMain", nativeQuery = true, resultRecordType = QueryCmntMainDTO.class,
            value = "SELECT trim(a.policy_no) AS policytNo " +
                    "      ,trim(a.process_date) AS processDate " +
                    "      ,trim(a.process_time) AS procesTime " +
                    "      ,trim(cancel_date) AS cancelDate " +
                    "      ,trim(a.function_code) AS functionCode " +
                    "      ,trim(desc) AS functionDesc " +
                    "      ,a.coverage_no AS coverageNo " +
                    "      ,trim(plan_code) AS planCode " +
                    "      ,trim(rate_scale) AS rateScale " +
                    "      ,trim(a.comments[109,110]) AS cmntYear " +
                    "      ,trim(a.comments[1,100]) AS comments1 " +
                    "FROM cmnt a " +
                    "JOIN etab b " +
                    "ON b.e_type = a.function_code " +
                    "AND b.code = 'CT' " +
                    "LEFT OUTER JOIN pscm c " +
                    "ON a.client_id = c.client_id " +
                    "AND a.policy_no = c.policy_no " +
                    "AND a.process_date = c.process_date "  +
                    "AND a.function_code[1] IN ('N','P') " +
                    "AND a.function_code = c.cmnt_class ")
    @QueryFilter(name = "clientId", expr = "a.client_id")
    public List<QueryCmntMainDTO> queryCmntMain(Criterion criterion) {
        return viewQueryService.executeByServiceMethod(criterion);
    }
}
```

## 複雜的查詢 - NamedParameterJdbcTemplate

此方式 是透過 Jpa 的 NamedParameterJdbcTemplate 方法 進行查詢

程式架構 類似 informix。

1. 注入 `NamedParameterJdbcTemplate`。
   
   ```java
   @Autowired
   private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
   ```

2. 撰寫 SQL 語法。
   
   ```java
   String sql1 = "SELECT * FROM addr " +
               "WHERE address LIKE :address";
   ```
   
   ```java
   String sql2 = "UPDATE addr " +
               "SET client_id = :clientIdNew " +
               "   ,addr_ind = :addrIndNew " +
               "   ,address = :addressNew " +
               "   ,tel = :telNew " +
               "WHERE client_id = :clientIdOri " +
               "  AND addr_ind = :addrIndOri " + 
               "  AND address = :addressOri " + 
               "  AND tel = :telOri ";
   ```
   
   - 若 變數為集合，要使用 `( )` 包起來
     
     ```java
     String sql = "SELECT * FROM gico " +
                  "WHERE client_id IN (:clientIdList)";
     ```

3. 透過 Map 設定參數。
   
   ```java
   Map<String, Object> params1 = new HashMap<>();
   params1.put("address", "%" + address + "%");
   ```
   
   ```java
   Map<String, Object> params2 = new HashMap<>();
   params2.put("clientIdNew", entityNew.getClientId());
   params2.put("addrIndNew", entityNew.getAddrInd());
   params2.put("addressNew", entityNew.getAddress());
   params2.put("telNew", entityNew.getTel());
   params2.put("clientIdOri", entityOri.getClientId());
   params2.put("addrIndOri", entityOri.getAddrInd());
   params2.put("addressOri", entityOri.getAddress());
   params2.put("telOri", entityOri.getTel());4. 
   ```

4. 執行 SQL。
- `單筆查詢` 透過 `namedParameterJdbcTemplate.queryForObject` 執行。
  
  ```java
  Long count = namedParameterJdbcTemplate.queryForObject(countSql + whereSql, params, Long.class);
  ```

- `多筆查詢` 透過 `namedParameterJdbcTemplate.query` 執行。
  
  透過 `BeanPropertyRowMapper` 可以自動將 下底線 轉換為 小駝峰。
  
  ```java
  List<Addr> addrList = namedParameterJdbcTemplate.query(sql1, params1, new BeanPropertyRowMapper<>(Addr.class));
  ```

- `增刪修` 透過 `namedParameterJdbcTemplate.update` 執行。
  
  ```java
  namedParameterJdbcTemplate.update(sql2, params2);
  ```

## 新增

先想辦法 取得 要新增的 entity 資料，

再透過 `entityWriteService.applyCommand()` 和 `SystemCommands.createCommand()` 執行。

因 新增 可能失敗，所以需要有 `try-catch`。

```java
@Autowired
private EntityWriteService entityWriteService;

public void insertAddr(AddrEntity addrEntity) {
    try {
        entityWriteService.applyCommand(SystemCommands.createCommand("AddrEntity", addrEntity));
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
```

## 修改

先想辦法 取得 變更後的 entity 資料，

再透過 `entityWriteService.applyCommand()` 和 `SystemCommands.updateCommand()` 執行。

執行修改時，會根據 entity 設定的 唯一值 修改對應的資料。

因 修改 可能失敗，所以需要有 `try-catch`。

```java
@Autowired
private EntityWriteService entityWriteService;

public void updateAddr(AddrEntity addrEntityNew) {
    try {
        entityWriteService.applyCommand(SystemCommands.updateCommand("AddrEntity", addrEntityNew));
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
```

## 刪除

先想辦法 取得 要刪除的 entity 資料，

再透過 `entityWriteService.applyCommand()` 和 `SystemCommands.deleteCommand()` 執行。

執行刪除時，會根據 entity 設定的 唯一值 刪除對應的資料。

因 刪除 可能失敗，所以需要有 `try-catch`。

```java
@Autowired
private EntityWriteService entityWriteService;

public void deleteAddr(AddrKey addrKey) {
    // 根據 AddrKey 取得 要刪除的 Addr 資料
    Criterion criterion = Criterion.and(
            Criterion.single("clientId", Criterion.QueryOperator.EQUAL, addrKey.getClientId()),
            Criterion.single("addrInd", Criterion.QueryOperator.EQUAL, addrKey.getAddrInd())
    );
    List<AddrEntity> addrList = viewQueryService.querySpec(AddrEntity.class, criterion);
    // 有資料，進行刪除作業
    if (!addrList.isEmpty()) {
        AddrEntity addrEntity = addrList.get(0);
        try {
            entityWriteService.applyCommand(SystemCommands.deleteCommand("AddrEntity", addrEntity));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```
